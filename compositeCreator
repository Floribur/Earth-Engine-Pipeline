/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var landsatCollection = ee.ImageCollection("LANDSAT/LC08/C02/T1_L2"),
  sentinelColleciton = ee.ImageCollection("COPERNICUS/S2_SR_HARMONIZED");
/***** End of imports. If edited, may not auto-convert in the playground. *****/
/* ////////////////////////////////////////////////////
// Import Script Modules from this repo
*/ ////////////////////////////////////////////////////
var areaCalculator = require("users/florianburkhardt/caboDelgado:areaCalculator");
var indexCalculator = require("users/florianburkhardt/caboDelgado:indexCalculator");
var params = require("users/florianburkhardt/caboDelgado:params");
var helper = require("users/florianburkhardt/caboDelgado:helperFunctions");
var classification = require("users/florianburkhardt/caboDelgado:classification");
var GLCMCalculator = require("users/florianburkhardt/caboDelgado:GLCMCalculator");
var classStatistics = require("users/florianburkhardt/caboDelgado:classStatistics");
var featureCollections = require("users/florianburkhardt/caboDelgado:featureCollections");

/*
  function to create an image composite for a specific year in a specific year
  region: of type ee.???, the region for which the image composite should be generated
  year: of type ee.Number (integer) from the year for which the image composite should be generated
*/
exports.run = function (CONFIG, year) {
  // create the data based on the input
  var startDate = ee.Date(year + "-01-01");
  var endDate = ee.Date(year + "-12-31");
  var prefix = year + "_";

  // get trainingData and property from imports based on the year
  var rawTrainingData = featureCollections.rawTrainingData[year]; // get raw training data
  var trainingPointsCollection = featureCollections.createDataset(
    rawTrainingData,
    CONFIG
  ); // create dataset based on that
  //print("Dataset collection", trainingPointsCollection)

  // TODO!!
  // Now only RF can be selected
  // set classifier. If there's none found, default to random forest
  /*
  var classifier = CLASSIFIERS.get(
    CONFIG.CLASSIFIERTYPE,
    CONFIG.RANDOM_FOREST_TREES
  ); // get classifier with parameters*/
  var classifier = ee.Classifier.smileRandomForest({
    numberOfTrees: CONFIG.RANDOM_FOREST_TREES,
    variablesPerSplit: null,
    minLeafPopulation: 1,
    bagFraction: 0.5,
    maxNodes: null,
    seed: 0,
  });

  /* ////////////////////////////////////////////////////
  // PREPARE DATA
  */ ////////////////////////////////////////////////////

  var collection;
  var glcm_collection;

  // get Sentinel or Landsat Image Collection depending on input parameter configuration
  if (CONFIG.IS_SENTINEL) {
    // Get Sentinel Imagery
    collection = sentinelColleciton
      .filterDate(startDate, endDate)
      .filter(
        ee.Filter.lt("CLOUDY_PIXEL_PERCENTAGE", CONFIG.MAX_CLOUD_COVERAGE)
      ); // Pre-filter to get less cloudy granules.

    // since the GLCM bands depend on the zoom factor, we don't apply any scaling to them...
    glcm_collection = collection.median();

    // add scaling to collection and mask clouds
    collection = collection
      .map(helper.maskS2clouds) // either mask clouds or divide to scale
      .median()
      //.divide(10000) // either mask clouds or use this to scale the image properly...
      .set("system:time_start", startDate.millis()); // set start date as time-start for image
  } else {
    // LANDSAT in all other cases

    // prepare collection
    collection = landsatCollection
      .filterBounds(CONFIG.REGION)
      .filterDate(startDate, endDate) // now it takes the dates from the input parameters
      //.sort('CLOUD_COVER', false) // sort the images by the cloud cover..., not used
      .filterMetadata("CLOUD_COVER", "less_than", CONFIG.MAX_CLOUD_COVERAGE); // only get images with cloud coverage < config
    //.clip(CONFIG.REGION) // not used, moved to later usage in the script according to best practices proposed by the documentation.

    // since the GLCM bands depend on the zoom factor, we don't apply any scaling to them...
    glcm_collection = collection.median();

    // add scaling to collection and mask clouds
    collection = collection
      .map(helper.prepSrL8) // using the google scale and masking clouds script
      .median()
      .set("system:time_start", startDate.millis()); // set start date as time-start for image
  }

  /*
    Calculate Pearson Correlation and print it to console
  */
  if (CONFIG.RUN_PEARSON_CORRELATION) {
    var PCBands = CONFIG.PEARSON_CORRELEATION_BANDS;
    for (var i = 0; i < PCBands.length; ++i) {
      // for each default band
      for (var j = 0; j < PCBands.length; ++j) {
        // compare it with another default band
        if (i < j) {
          // instead of i != j to remove duplicates
          var inputImage = collection.select([PCBands[i], PCBands[j]]); // comapre the two bands
          var correlation = inputImage.reduceRegion({
            reducer: ee.Reducer.pearsonsCorrelation(),
            geometry: CONFIG.REGION,
            scale: CONFIG.COLLECTION_SCALE,
            //maxPixels: 2000000000, // more pixels than caboDelgado has...
            bestEffort: true,
          });
          // objects contains "correlation" and "p-value".
          print(
            "Correlation for:",
            inputImage.bandNames(),
            correlation,
            ee.Dictionary(correlation).get("correlation")
          );
        }
      }
    }
  }

  /* ////////////////////////////////////////////////////
  // CALCULATE GLCM Textures and add to COLLECTION Bands
  */ ////////////////////////////////////////////////////

  if (CONFIG.GLCM) {
    // calculate GLCM Bands
    var GLCMBands = GLCMCalculator.createTextureBands(glcm_collection, CONFIG); // using glcm_collection as input bands / image collection

    // Add GLCM Bands to collection image
    collection = collection.addBands(GLCMBands); // add the newly calcualted glcm bands to collection
  }

  /* ////////////////////////////////////////////////////
  // CALCULATE INDEXES and add to COLLECTION Bands
  */ ////////////////////////////////////////////////////
  if (CONFIG.VEGETATION_INDEXES) {
    // calculate indexes
    var NDVI = indexCalculator.NDVI(collection, CONFIG.IS_SENTINEL); // Normalized Difference Vegetation Index (NDVI)
    var NDWI = indexCalculator.NDWI(collection, CONFIG.IS_SENTINEL); // Normalized Difference Water Index (NDWI)
    var EVI = indexCalculator.EVI(collection, CONFIG.IS_SENTINEL); // Enhanced Vegetation Index (EVI)
    var SAVI = indexCalculator.SAVI(collection, CONFIG.IS_SENTINEL); // Soil Adjusted Vegetation Index (SAVI)

    // Add new indexes as bands to collection
    var indexBands = ee.Image([NDVI, NDWI, EVI, SAVI]);
    collection = collection.addBands(indexBands);
    //print("collection with Index Bands:" , collection)
  }

  /* ////////////////////////////////////////////////////
  // Remove unused bands and calculate final composite image that can be used for training
  */ ////////////////////////////////////////////////////

  // Final Composite Image, remove bands we don't want to use as input!
  var compositeImage = helper.removeBands(
    collection,
    CONFIG.BANDS_TO_BE_REMOVED
  );
  // compositeImage = compositeImage.toInt32(); // cast all of them to the same type.. if needed for calculations or smth.
  print(prefix + "Composite Image", compositeImage);

  /* ////////////////////////////////////////////////////
  // Show True Color and Indexes as layers on the map
  */ ////////////////////////////////////////////////////

  // Sentinel True Color Params or Landsat True Color Params
  var trueColorParams = params.trueColorLandsat;
  if (CONFIG.IS_SENTINEL) {
    trueColorParams = params.trueColorSentinel;
  }

  Map.addLayer(
    collection.clip(CONFIG.REGION),
    trueColorParams,
    prefix + "True Color",
    !CONFIG.DEACTIVATE_MAP_DRAWING && true
  ); // TRUE COLOR USES COLLECTION INSTEAD OF compositeImage, since we might remove SR_B4 for the classification!
  if (CONFIG.VEGETATION_INDEXES) {
    Map.addLayer(
      compositeImage.clip(CONFIG.REGION),
      params.NDVI,
      prefix + "Normalized Difference Vegetation Index (NDVI)",
      false
    );
    Map.addLayer(
      compositeImage.clip(CONFIG.REGION),
      params.EVI,
      prefix + "Enhanced Vegetation Index (EVI)",
      false
    );
    Map.addLayer(
      compositeImage.clip(CONFIG.REGION),
      params.NDWI,
      prefix + "Normalized Difference Water Index (NDWI)",
      false
    );
    Map.addLayer(
      compositeImage.clip(CONFIG.REGION),
      params.SAVI,
      prefix + "Soil Adjusted Vegetation Index (SAVI)",
      false
    );
  }
  /* ////////////////////////////////////////////////////
  // CLASSIFICATION
  */ ////////////////////////////////////////////////////

  // create training data (map polygons to pixel values)
  var dataset = classification.createTrainingData(
    compositeImage,
    trainingPointsCollection,
    CONFIG
  );
  print("Dataset:", dataset.size());

  // calculate seperability measurements?
  if (CONFIG.MAKE_SEPERABILITY_ANALYSIS) {
    // calculate pre-class statistics
    if (CONFIG.JM_DISTANCE_MANANZE) {
      classStatistics.calcJmDistance(
        compositeImage,
        trainingPointsCollection,
        CONFIG,
        year
      ); // sosditos way
    } else {
      classStatistics.calculate(
        dataset,
        compositeImage.bandNames(),
        CONFIG,
        year
      ); // my way
    }
  }

  // Classification of image
  if (CONFIG.MAKE_CLASSIFICATION) {
    // split into training and validation set
    var splitDataset = featureCollections.splitData(
      dataset,
      CONFIG.FEATURE_COLLECTION_SPLIT
    );
    var trainingData = splitDataset.training;
    var validationData = splitDataset.validation;
    print(
      "Dataset size: ",
      dataset.size(),
      "Training and validation was split by",
      CONFIG.FEATURE_COLLECTION_SPLIT,
      "Training data size: ",
      trainingData.size(),
      "Validation data size:",
      validationData.size()
    );

    //Train the classifier with the training data
    var trainedClassifier = classification.trainClassifier(
      classifier,
      trainingData,
      CONFIG.CLASSIFICATION_LABEL,
      compositeImage
    );

    // Explain trained classifier
    if (CONFIG.EXPLAIN_CLASSIFIER) {
      print("Results of trained classifier", trainedClassifier.explain());
    }

    // Validate trained classifier using the validation data and trained classifier
    classification.createValidationErrorMatrix(
      validationData,
      trainedClassifier,
      CONFIG
    );

    // Classify image based on trained classifier
    var classifiedImage = classification.createClassifiedImage(
      compositeImage,
      trainedClassifier
    );
    //  print("classifiedImage", classifiedImage)
    //classifiedImage = classifiedImage.clip(region); // finally clip region in the end...

    //Map the classified image
    Map.addLayer(
      classifiedImage.clip(CONFIG.REGION),
      params.classifiedImage,
      prefix + "Classified Image",
      !CONFIG.DEACTIVATE_MAP_DRAWING && true
    );

    var imageFileName = helper.createFileName("CLASSIFIED-IMAGE", CONFIG, year);
    var imageFolderName = helper.createFolderName(CONFIG);

    // Exportm classified image
    Export.image.toDrive({
      image: classifiedImage,
      description: imageFileName,
      folder: imageFolderName,
      region: CONFIG.REGION,
      scale: CONFIG.COLLECTION_SCALE,
      // crs: 'EPSG:5070',
      skipEmptyTiles: true, // skip masked regions
      fileFormat: "GeoTIFF",
      maxPixels: 10000000000000,
    });

    classification.classificationChart(
      classifiedImage,
      params.classNames,
      CONFIG
    );

    // Calculate the accuracy of the classification using the confusion matrix
    //var confusionMatrix = classification.createConfusionMatrixAndPrintAccuracy(trainedClassifier)
    // todo later, correctly...

    // add each class to the map, individually
    if (CONFIG.SHOW_CLASS_INDIVIDUALLY) {
      for (var classNr = 0; classNr <= 5; classNr++) {
        var mapOfClass = classifiedImage
          .clip(CONFIG.REGION)
          .eq(classNr)
          .selfMask(); // only show the the specific class
        Map.addLayer(
          mapOfClass,
          params.oneClassImage(classNr), // get the Palette-Color from this class
          prefix + params.classNames[classNr] + " (" + classNr + ")", // get name of that class from params
          false
        );
      }
    }
  }

  /* ////////////////////////////////////////////////////
  // Area Calculation of each class
  */ ////////////////////////////////////////////////////
  var areaOfClasses = [];
  // calculate area sizes, if classification was made
  if (CONFIG.MAKE_CLASSIFICATION) {
    areaOfClasses = areaCalculator.calculateAreaOfClasses(
      classifiedImage,
      CONFIG,
      "class"
    );
  }

  /* ////////////////////////////////////////////////////
  // RETURN
  */ ////////////////////////////////////////////////////

  // create Object to be returned
  var response = {
    classifierType: CONFIG.CLASSIFIERTYPE,
    prefix: prefix,
    image: compositeImage,
    startDate: startDate,
    endDate: endDate,
    classifiedImage: CONFIG.MAKE_CLASSIFICATION ? classifiedImage : false, // only return if calculated
    areaOfClasses: areaOfClasses, // the calculated area based on the classification for each individual class in km^2
  };

  return response;
};
